from __future__ import annotations

__all__ = ["TextDocument"]

import dataclasses
import random
from typing import Any, ClassVar, Dict, List, Optional, Type
import uuid

from medkit.core.id import generate_id
from medkit.core import dict_conv
from medkit.core.text.annotation import TextAnnotation, Segment
from medkit.core.text.annotation_container import TextAnnotationContainer
from medkit.core.text.span import Span


@dataclasses.dataclass(init=False)
class TextDocument:
    """
    Document holding text annotations

    Annotations must be subclasses of `TextAnnotation`.

    Attributes
    ----------
    uid:
        Unique identifier of the document.
    text:
        Full document text.
    anns:
        Annotations of the document. Stored in an
        :class:`~.TextAnnotationContainer` but can be passed as a list at init.
    metadata:
        Document metadata.
    raw_segment:
        Auto-generated segment containing the full unprocessed document text. To
        get the raw text as an annotation to pass to processing operations:

        >>> doc = TextDocument(text="hello")
        >>> raw_text = doc.anns.get(label=TextDocument.RAW_LABEL)[0]
    """

    RAW_LABEL: ClassVar[str] = "RAW_TEXT"

    uid: str
    anns: TextAnnotationContainer
    metadata: Dict[str, Any]
    raw_segment: Segment

    def __init__(
        self,
        text: str,
        anns: Optional[List[TextAnnotation]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        uid: Optional[str] = None,
    ):
        if anns is None:
            anns = []
        if metadata is None:
            metadata = {}
        if uid is None:
            uid = generate_id()

        self.uid = uid
        self.metadata = metadata

        # auto-generated raw segment to hold the text
        self.raw_segment = self._generate_raw_segment(text, uid)

        self.anns = TextAnnotationContainer(
            doc_id=self.uid, raw_segment=self.raw_segment
        )
        for ann in anns:
            self.anns.add(ann)

    @classmethod
    def _generate_raw_segment(cls, text: str, doc_id: str) -> Segment:
        # generate deterministic uuid based on document uid
        # so that the annotation uid is the same if the doc uid is the same
        rng = random.Random(doc_id)
        uid = str(uuid.UUID(int=rng.getrandbits(128)))

        return Segment(
            label=cls.RAW_LABEL,
            spans=[Span(0, len(text))],
            text=text,
            uid=uid,
        )

    @property
    def text(self) -> str:
        return self.raw_segment.text

    def __init_subclass__(cls):
        super().__init_subclass__()
        # type-annotated intermediary variable needed to keep mypy happy
        parent_class: Type = TextDocument
        dict_conv.register_subclass(parent_class, cls)

    def to_dict(self) -> Dict[str, Any]:
        anns = [a.to_dict() for a in self.anns]
        doc_dict = dict(
            uid=self.uid,
            text=self.text,
            anns=anns,
            metadata=self.metadata,
        )
        dict_conv.add_class_name_to_data_dict(self, doc_dict)
        return doc_dict

    @staticmethod
    def from_dict(doc_dict: Dict[str, Any]) -> TextDocument:
        """
        Creates a TextDocument from a dict

        Parameters
        ----------
        doc_dict: dict
            A dictionary from a serialized TextDocument as generated by to_dict()
        """

        # dispatch to subclass from_dict() if class_name in dict corresponds to a subclass
        if not dict_conv.check_class_matches_data_dict(
            TextDocument, doc_dict, should_raise=False
        ):
            subclass = dict_conv.get_subclass_for_data_dict(TextDocument, doc_dict)
            return subclass.from_dict(doc_dict)

        dict_conv.check_class_matches_data_dict(TextDocument, doc_dict)
        anns = [TextAnnotation.from_dict(a) for a in doc_dict["anns"]]
        return TextDocument(
            uid=doc_dict["uid"],
            text=doc_dict["text"],
            anns=anns,
            metadata=doc_dict["metadata"],
        )
