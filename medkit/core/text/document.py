from __future__ import annotations

__all__ = ["TextDocument"]

import random
from typing import Any, Dict, Optional
import uuid

from medkit.core.id import generate_id
from medkit.core.store import Store, DictStore
from medkit.core.text.annotation import Segment, Entity, Relation
from medkit.core.text.annotation_container import TextAnnotationContainer
from medkit.core.text.span import Span


class TextDocument:
    """Document holding text annotations

    Annotations must be subclasses of `TextAnnotation`.

    """

    RAW_LABEL = "RAW_TEXT"
    """Label to be used for raw text
    """

    def __init__(
        self,
        text: str,
        metadata: Optional[Dict[str, Any]] = None,
        uid: Optional[str] = None,
        store: Optional[Store] = None,
    ):
        """
        Parameters
        ----------
        text:
            Document text
        metadata: dict  # TODO
            Document metadata
        uid: str, Optional
            Document identifier. If None, an uuid is generated.
        store:
            Optional shared store to hold the document annotations. If none provided,
            an internal store will be used.

        Examples
        --------
        To get the raw text as an annotation to pass to processing operations:

        >>> doc = TextDocument(text="hello")
        >>> raw_text = doc.anns.get(label=TextDocument.RAW_LABEL)[0]
        """
        if uid is None:
            uid = generate_id()
        if metadata is None:
            metadata = {}
        if store is None:
            store = DictStore()
            has_shared_store = False
        else:
            has_shared_store = True

        self.uid: str = uid
        self.store: Store = store
        self.has_shared_store = has_shared_store
        self.metadata: Dict[str, Any] = metadata  # TODO: what is metadata format ?

        # auto-generated raw segment to hold the text
        self.raw_segment: Segment = self._generate_raw_segment(text, uid)
        self.anns = TextAnnotationContainer(self.raw_segment, store)

    @classmethod
    def _generate_raw_segment(cls, text: str, doc_id: str) -> Segment:
        # generate deterministic uuid based on document uid
        # so that the annotation uid is the same if the doc uid is the same
        rng = random.Random(doc_id)
        uid = str(uuid.UUID(int=rng.getrandbits(128)))

        return Segment(
            label=cls.RAW_LABEL,
            spans=[Span(0, len(text))],
            text=text,
            uid=uid,
        )

    @property
    def text(self) -> str:
        return self.raw_segment.text

    def to_dict(self) -> Dict[str, Any]:
        anns = [ann.to_dict() for ann in self.anns]
        return dict(
            uid=self.uid,
            text=self.text,
            anns=anns,
            metadata=self.metadata,
            class_name=self.__class__.__name__,
        )

    @classmethod
    def from_dict(cls, doc_dict: Dict[str, Any]) -> TextDocument:
        """
        Creates a TextDocument from a dict

        Parameters
        ----------
        doc_dict: dict
            A dictionary from a serialized TextDocument as generated by to_dict()
        """
        anns = []
        for annotation_dict in doc_dict["anns"]:
            if annotation_dict["class_name"] == "Relation":
                anns.append(Relation.from_dict(annotation_dict))
            elif annotation_dict["class_name"] == "Segment":
                anns.append(Segment.from_dict(annotation_dict))
            elif annotation_dict["class_name"] == "Entity":
                anns.append(Entity.from_dict(annotation_dict))

        doc = cls(
            uid=doc_dict["uid"], metadata=doc_dict["metadata"], text=doc_dict["text"]
        )

        for ann in anns:
            doc.anns.add(ann)

        return doc
