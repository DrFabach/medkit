from __future__ import annotations

__all__ = ["Attribute", "AttributeValue"]

import abc
import dataclasses
from typing import Any, Dict, Optional, Type, Union

from medkit.core import dict_conv
from medkit.core.id import generate_id


class AttributeValue(abc.ABC):
    """
    Abstract base class for custom attributes values
    """

    def __init_subclass__(cls):
        super().__init_subclass__()
        # type-annotated intermediary variable needed to keep mypy happy
        parent_class: Type = AttributeValue
        dict_conv.register_subclass(parent_class, cls)

    @staticmethod
    def from_dict(ann_dict: Dict[str, Any]) -> AttributeValue:
        subclass = dict_conv.get_subclass_for_data_dict(AttributeValue, ann_dict)
        return subclass.from_dict(ann_dict)

    @abc.abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        raise NotImplementedError()

    @abc.abstractmethod
    def get_simple_representation(self) -> Union[int, float, bool, str]:
        """
        Return a numeric or string representation of the value to be used when
        exporting to format that do not support complex attributes values, such
        as Brat
        """
        raise NotImplementedError()


@dataclasses.dataclass
class Attribute:
    """
    Medkit attribute, to be added to an annotation

    Attributes
    ----------
    label:
        The attribute label
    value:
        The value of the attribute. Should be either simple built-in types (int,
        float, bool, str) or collections of these types (list, dict, tuple). For
        more complex data use subclasses of :class:`~.AttributeValue`.
    metadata:
        The metadata of the attribute
    uid:
        The identifier of the attribute
    """

    label: str
    value: Optional[Any] = None
    metadata: Dict[str, Any] = dataclasses.field(default_factory=dict)
    uid: str = dataclasses.field(default_factory=generate_id)

    def __init_subclass__(cls):
        super().__init_subclass__()
        # type-annotated intermediary variable needed to keep mypy happy
        parent_class: Type = Attribute
        dict_conv.register_subclass(parent_class, cls)

    def to_dict(self) -> Dict[str, Any]:
        value = self.value
        # handle object value
        if isinstance(value, AttributeValue):
            value = value.to_dict()

        attribute_dict = dict(
            uid=self.uid,
            label=self.label,
            value=value,
            metadata=self.metadata,
        )
        dict_conv.add_class_name_to_data_dict(self, attribute_dict)
        return attribute_dict

    def copy(self) -> Attribute:
        """
        Create a new attribute that is a copy of the current instance, but
        with a new identifier

        This is used when we want to duplicate an existing attribute onto a
        different annotation.
        """
        return dataclasses.replace(self, uid=generate_id())

    @staticmethod
    def from_dict(attribute_dict: Dict[str, Any]) -> Attribute:
        """
        Creates an Attribute from a dict

        Parameters
        ----------
        attribute_dict: dict
            A dictionary from a serialized Attribute as generated by to_dict()
        """

        # dispatch to subclass from_dict() if class_name in dict corresponds to a subclass
        if not dict_conv.check_class_matches_data_dict(
            Attribute, attribute_dict, should_raise=False
        ):
            subclass = dict_conv.get_subclass_for_data_dict(Attribute, attribute_dict)
            return subclass.from_dict(attribute_dict)

        value = attribute_dict["value"]
        # handle object value
        if isinstance(value, dict) and dict_conv.is_convertible_data_dict(value):
            value = AttributeValue.from_dict(value)
        return Attribute(
            uid=attribute_dict["uid"],
            label=attribute_dict["label"],
            value=value,
            metadata=attribute_dict["metadata"],
        )
