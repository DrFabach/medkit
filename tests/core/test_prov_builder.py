from medkit.core import generate_id
from medkit.core.prov_builder import ProvBuilder


class _TextItem:
    def __init__(self, text):
        """Mock text item with id"""

        self.id = generate_id()
        self.text = text


class _Generator:
    def __init__(self, prov_builder=None):
        """Mock operation generating text items"""

        self.id = generate_id()
        self.prov_builder = prov_builder

    def generate(self, nb_items):
        items = [
            _TextItem(f"This is the text item number {i}.") for i in range(nb_items)
        ]

        if self.prov_builder is not None:
            for item in items:
                self.prov_builder.add_prov(item.id, self.id, source_ids=[])
        return items


class _Prefixer:
    def __init__(self, prov_builder=None):
        """Mock operation prefixing items"""

        self.id = generate_id()
        self.prov_builder = prov_builder

    def prefix(self, items):
        prefixed_items = []
        for item in items:
            prefixed_item = _TextItem("Hello! " + item.text)
            prefixed_items.append(prefixed_item)
            if self.prov_builder is not None:
                self.prov_builder.add_prov(
                    prefixed_item.id, self.id, source_ids=[item.id]
                )
        return prefixed_items


class _Splitter:
    def __init__(self, prov_builder=None):
        """Mock operation splitting items"""

        self.id = generate_id()
        self.prov_builder = prov_builder

    def split(self, items):
        split_items = []
        for item in items:
            half = len(item.text) // 2
            left_item = _TextItem(item.text[:half])
            split_items.append(left_item)
            right_item = _TextItem(item.text[half:])
            split_items.append(right_item)

            if self.prov_builder is not None:
                self.prov_builder.add_prov(left_item.id, self.id, source_ids=[item.id])
                self.prov_builder.add_prov(right_item.id, self.id, source_ids=[item.id])
        return split_items


class _Merger:
    """Mock operation merging items"""

    def __init__(self, prov_builder=None):
        self.id = generate_id()
        self.prov_builder = prov_builder

    def merge(self, items):
        text = "".join(s.text for s in items)
        merged_item = _TextItem(text)
        if self.prov_builder is not None:
            self.prov_builder.add_prov(
                merged_item.id, self.id, source_ids=[s.id for s in items]
            )
        return merged_item


def test_single_item_with_no_source():
    """Very simple use case with only one item generated"""
    builder = ProvBuilder()
    # generate 1 item
    generator = _Generator(builder)
    item = generator.generate(1)[0]

    graph = builder.graph
    graph.check_sanity()

    # graph must have a node for generated item
    node = graph.get_node(item.id)
    assert node.data_item_id == item.id
    assert node.operation_id == generator.id
    assert not node.source_ids
    assert not node.derived_ids

    assert graph.get_nodes() == [node]


def test_multiple_items():
    """Very simple use case with several items generated by the same operation"""
    builder = ProvBuilder()
    # generate 2 items
    generator = _Generator(builder)
    items = generator.generate(2)

    graph = builder.graph

    graph.check_sanity()
    # graph must have a node for each generated item
    assert len(graph.get_nodes()) == len(items)

    for item in items:
        node = graph.get_node(item.id)
        assert node.data_item_id == item.id
        assert node.operation_id == generator.id


def test_multiple_items_with_sources():
    """Several items generated by an operation, then used as input to another operation"""
    builder = ProvBuilder()
    # generate 2 items then prefix them
    generator = _Generator(builder)
    prefixer = _Prefixer(builder)
    input_items = generator.generate(2)
    prefixed_items = prefixer.prefix(input_items)

    graph = builder.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(input_items) + len(prefixed_items)

    for input_item, prefixed_item in zip(input_items, prefixed_items):
        input_node = graph.get_node(input_item.id)
        assert input_node.operation_id == generator.id
        assert not input_node.source_ids
        # input item was used to derive prefixed item
        assert input_node.derived_ids == [prefixed_item.id]

        prefixed_node = graph.get_node(prefixed_item.id)
        assert prefixed_node.operation_id == prefixer.id
        # prefixed item was derived from input item
        assert prefixed_node.source_ids == [input_item.id]
        assert not prefixed_node.derived_ids


def test_intermediate_operation():
    """Input items passed to an intermediate operation, then intermediate items passed to another operatio"""
    builder = ProvBuilder()
    # generate 2 items and prefix them twice with 2 different operations
    generator = _Generator(builder)
    prefixer_1 = _Prefixer(builder)
    prefixer_2 = _Prefixer(builder)
    input_items = generator.generate(2)
    prefixed_items_1 = prefixer_1.prefix(input_items)
    prefixed_items_2 = prefixer_2.prefix(prefixed_items_1)

    graph = builder.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(input_items) + len(prefixed_items_1) + len(
        prefixed_items_2
    )

    for input_item, prefixed_item_1, prefixed_item_2 in zip(
        input_items, prefixed_items_1, prefixed_items_2
    ):
        input_node = graph.get_node(input_item.id)
        assert input_node.operation_id == generator.id
        assert not input_node.source_ids
        # input item was used to derive 1st prefixed item
        assert input_node.derived_ids == [prefixed_item_1.id]

        prefixed_node_1 = graph.get_node(prefixed_item_1.id)
        assert prefixed_node_1.operation_id == prefixer_1.id
        # 1st prefixed item was derived from input item
        assert prefixed_node_1.source_ids == [input_item.id]
        # 1st prefixed item was used to derive 2st prefixed item
        assert prefixed_node_1.derived_ids == [prefixed_item_2.id]

        prefixed_node_2 = graph.get_node(prefixed_item_2.id)
        assert prefixed_node_2.operation_id == prefixer_2.id
        # 2d prefixed item was derived from 1st prefixed item
        assert prefixed_node_2.source_ids == [prefixed_item_1.id]
        assert not prefixed_node_2.derived_ids


def test_multiple_derived():
    """One item used to derive several new items"""
    builder = ProvBuilder()
    # generate 1 item then split it in 2
    generator = _Generator(builder)
    splitter = _Splitter(builder)
    input_items = generator.generate(1)
    input_item = input_items[0]
    split_items = splitter.split(input_items)

    graph = builder.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(input_items) + len(split_items)

    node = graph.get_node(input_item.id)
    assert node.operation_id == generator.id
    assert not node.source_ids
    # input item was used to derive 2 split items
    assert node.derived_ids == [s.id for s in split_items]

    for split_item in split_items:
        node = graph.get_node(split_item.id)
        assert node.operation_id == splitter.id
        # each split item was derived from the input item
        assert node.source_ids == [input_item.id]
        assert not node.derived_ids


def test_multiple_source():
    """Data items derived from several input items"""
    builder = ProvBuilder()
    # generate 2 item and merge them
    generator = _Generator(builder)
    merger = _Merger(builder)
    input_items = generator.generate(2)
    merged_item = merger.merge(input_items)

    graph = builder.graph
    graph.check_sanity()
    assert (
        len(graph.get_nodes()) == len(input_items) + 1
    )  # 2 input items + 1 merged item

    node = graph.get_node(merged_item.id)
    assert node.operation_id == merger.id
    # merged item was derived from all input items
    assert node.source_ids == [s.id for s in input_items]

    # all input items were used to derive merged item
    for input_item in input_items:
        node = graph.get_node(input_item.id)
        assert node.derived_ids == [merged_item.id]


def test_partial_provenance():
    """Data items generated from input items for which no provenance info is available"""
    builder = ProvBuilder()
    # generate 2 items then split them it in 2 them merge them
    # provenance info will be provided only by Merger operation
    generator = _Generator(prov_builder=None)
    splitter = _Splitter(prov_builder=None)
    merger = _Merger(builder)
    input_items = generator.generate(2)
    split_items = splitter.split(input_items)
    merged_item = merger.merge(split_items)

    graph = builder.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(split_items) + 1

    # operation and source ids are available for merged item
    merged_node = graph.get_node(merged_item.id)
    assert merged_node.operation_id == merger.id
    assert merged_node.source_ids == [s.id for s in split_items]

    # split items have "stub nodes" with no info about how they were generated,
    # but info about how they were used to derive merged item
    split_node = graph.get_node(split_items[0].id)
    assert split_node.operation_id is None
    assert not split_node.source_ids
    assert split_node.derived_ids == [merged_item.id]

    # no node is available for the input items
    assert graph.has_node(input_items[0].id) is False
