from medkit.core.prov_tracer import ProvTracer
from tests.unit.core.prov_tracer._common import Generator, Prefixer, Splitter, Merger


def test_single_item_with_no_source():
    """Very simple use case with only one item generated"""
    tracer = ProvTracer()
    # generate 1 item
    generator = Generator(tracer)
    item = generator.generate(1)[0]

    graph = tracer.graph
    graph.check_sanity()

    # graph must have a node for generated item
    node = graph.get_node(item.id)
    assert node.data_item_id == item.id
    assert node.operation_id == generator.id
    assert not node.source_ids
    assert not node.derived_ids

    assert graph.get_nodes() == [node]


def test_multiple_items():
    """Very simple use case with several items generated by the same operation"""
    tracer = ProvTracer()
    # generate 2 items
    generator = Generator(tracer)
    items = generator.generate(2)

    graph = tracer.graph

    graph.check_sanity()
    # graph must have a node for each generated item
    assert len(graph.get_nodes()) == len(items)

    for item in items:
        node = graph.get_node(item.id)
        assert node.data_item_id == item.id
        assert node.operation_id == generator.id


def test_multiple_items_with_sources():
    """Several items generated by an operation, then used as input to another operation
    """
    tracer = ProvTracer()
    # generate 2 items then prefix them
    generator = Generator(tracer)
    prefixer = Prefixer(tracer)
    input_items = generator.generate(2)
    prefixed_items = prefixer.prefix(input_items)

    graph = tracer.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(input_items) + len(prefixed_items)

    for input_item, prefixed_item in zip(input_items, prefixed_items):
        input_node = graph.get_node(input_item.id)
        assert input_node.operation_id == generator.id
        assert not input_node.source_ids
        # input item was used to derive prefixed item
        assert input_node.derived_ids == [prefixed_item.id]

        prefixed_node = graph.get_node(prefixed_item.id)
        assert prefixed_node.operation_id == prefixer.id
        # prefixed item was derived from input item
        assert prefixed_node.source_ids == [input_item.id]
        assert not prefixed_node.derived_ids


def test_intermediate_operation():
    """Input items passed to an intermediate operation, then intermediate items passed to another operatio
    """
    tracer = ProvTracer()
    # generate 2 items and prefix them twice with 2 different operations
    generator = Generator(tracer)
    prefixer_1 = Prefixer(tracer)
    prefixer_2 = Prefixer(tracer)
    input_items = generator.generate(2)
    prefixed_items_1 = prefixer_1.prefix(input_items)
    prefixed_items_2 = prefixer_2.prefix(prefixed_items_1)

    graph = tracer.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(input_items) + len(prefixed_items_1) + len(
        prefixed_items_2
    )

    for input_item, prefixed_item_1, prefixed_item_2 in zip(
        input_items, prefixed_items_1, prefixed_items_2
    ):
        input_node = graph.get_node(input_item.id)
        assert input_node.operation_id == generator.id
        assert not input_node.source_ids
        # input item was used to derive 1st prefixed item
        assert input_node.derived_ids == [prefixed_item_1.id]

        prefixed_node_1 = graph.get_node(prefixed_item_1.id)
        assert prefixed_node_1.operation_id == prefixer_1.id
        # 1st prefixed item was derived from input item
        assert prefixed_node_1.source_ids == [input_item.id]
        # 1st prefixed item was used to derive 2st prefixed item
        assert prefixed_node_1.derived_ids == [prefixed_item_2.id]

        prefixed_node_2 = graph.get_node(prefixed_item_2.id)
        assert prefixed_node_2.operation_id == prefixer_2.id
        # 2d prefixed item was derived from 1st prefixed item
        assert prefixed_node_2.source_ids == [prefixed_item_1.id]
        assert not prefixed_node_2.derived_ids


def test_multiple_derived():
    """One item used to derive several new items"""
    tracer = ProvTracer()
    # generate 1 item then split it in 2
    generator = Generator(tracer)
    splitter = Splitter(tracer)
    input_items = generator.generate(1)
    input_item = input_items[0]
    split_items = splitter.split(input_items)

    graph = tracer.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(input_items) + len(split_items)

    node = graph.get_node(input_item.id)
    assert node.operation_id == generator.id
    assert not node.source_ids
    # input item was used to derive 2 split items
    assert node.derived_ids == [s.id for s in split_items]

    for split_item in split_items:
        node = graph.get_node(split_item.id)
        assert node.operation_id == splitter.id
        # each split item was derived from the input item
        assert node.source_ids == [input_item.id]
        assert not node.derived_ids


def test_multiple_source():
    """Data items derived from several input items"""
    tracer = ProvTracer()
    # generate 2 item and merge them
    generator = Generator(tracer)
    merger = Merger(tracer)
    input_items = generator.generate(2)
    merged_item = merger.merge(input_items)

    graph = tracer.graph
    graph.check_sanity()
    assert (
        len(graph.get_nodes()) == len(input_items) + 1
    )  # 2 input items + 1 merged item

    node = graph.get_node(merged_item.id)
    assert node.operation_id == merger.id
    # merged item was derived from all input items
    assert node.source_ids == [s.id for s in input_items]

    # all input items were used to derive merged item
    for input_item in input_items:
        node = graph.get_node(input_item.id)
        assert node.derived_ids == [merged_item.id]


def test_partial_provenance():
    """Data items generated from input items for which no provenance info is available
    """
    tracer = ProvTracer()
    # generate 2 items then split them it in 2 them merge them
    # provenance info will be provided only by Merger operation
    generator = Generator(prov_tracer=None)
    splitter = Splitter(prov_tracer=None)
    merger = Merger(tracer)
    input_items = generator.generate(2)
    split_items = splitter.split(input_items)
    merged_item = merger.merge(split_items)

    graph = tracer.graph
    graph.check_sanity()
    assert len(graph.get_nodes()) == len(split_items) + 1

    # operation and source ids are available for merged item
    merged_node = graph.get_node(merged_item.id)
    assert merged_node.operation_id == merger.id
    assert merged_node.source_ids == [s.id for s in split_items]

    # split items have "stub nodes" with no info about how they were generated,
    # but info about how they were used to derive merged item
    split_node = graph.get_node(split_items[0].id)
    assert split_node.operation_id is None
    assert not split_node.source_ids
    assert split_node.derived_ids == [merged_item.id]

    # no node is available for the input items
    assert graph.has_node(input_items[0].id) is False
